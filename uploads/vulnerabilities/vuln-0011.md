# GStreamer Pipeline Injection via STUN Server Parameter Enables Remote Code Execution

**ID:** vuln-0011
**Severity:** CRITICAL
**Found:** 2026-01-26 04:35:37 UTC
**Target:** /workspace/streamlinux/linux-gui
**Endpoint:** /workspace/streamlinux/linux-gui/webrtc_streamer.py
**Method:** Python
**CVSS:** 9.6

## Description

A critical GStreamer pipeline injection vulnerability exists in the StreamLinux Linux GUI application. The STUN server configuration parameter is directly interpolated into the GStreamer pipeline string without any validation or sanitization. This allows an attacker to inject arbitrary GStreamer elements using the '!' character (GStreamer's element linker), enabling file operations, network exfiltration, denial of service, and potential remote code execution.

The vulnerability is present in webrtc_streamer.py at lines 564 and 587, where `stun-server={self.config.stun_server}` is used in the pipeline construction. An attacker who can influence the STUN server configuration (via QR codes, signaling messages, or configuration files) can completely compromise the system.

## Impact

Successful exploitation of this vulnerability enables:

**Arbitrary File Write**
- Overwrite system configuration files (/etc/passwd, sudoers, ssh config)
- Create malicious scripts in autorun locations (~/.bashrc, /etc/profile.d/)
- Plant backdoors or modify SSH authorized_keys for persistent access

**Data Exfiltration**
- Exfiltrate screen capture data to external servers via udpsink
- Steal sensitive information visible on screen (credentials, documents)
- Complete session hijacking and monitoring

**Internal Network Access (SSRF)**
- Scan internal network via GStreamer's HTTP elements (souphttpsrc)
- Access internal admin panels and services
- Cloud metadata service access (169.254.169.254 for AWS/Azure/GCP)

**Denial of Service**
- Crash the application via malformed pipeline elements
- Persistent DoS if auto-restart is enabled
- System resource exhaustion

**Potential Remote Code Execution**
- Certain GStreamer plugins allow command execution
- File write can lead to RCE when combined with autorun scripts
- Privilege escalation through system file modification

**Attack Scenario:**
An attacker crafts a malicious QR code containing a STUN server parameter with injection payloads. When scanned by the victim's StreamLinux Android app, the Linux GUI constructs the GStreamer pipeline with the injected elements, executing arbitrary operations with the user's privileges.

## Technical Analysis

The vulnerability stems from the direct interpolation of user-controlled input into a GStreamer pipeline construction string. GStreamer's pipeline syntax uses the '!' character to link elements together, allowing complex pipeline construction. By injecting '!' followed by arbitrary element names and properties, an attacker can append malicious elements to the pipeline.

**Vulnerable Code (webrtc_streamer.py):**

```python
# Lines 563-575 (primary location)
pipeline_str = f'''
    webrtcbin name=webrtc bundle-policy=max-bundle stun-server={self.config.stun_server}
    {capture_src}
    ! videoconvert
    ! videoscale
    ...
'''

# Lines 586-597 (fallback after audio failure)
pipeline_str = f'''
    webrtcbin name=webrtc bundle-policy=max-bundle stun-server={self.config.stun_server}
    {capture_src}
    ! videoconvert
    ...
'''
```

**Root Cause:**
1. No validation of `self.config.stun_server` value
2. Direct f-string interpolation into pipeline string
3. No escaping or quoting of the parameter
4. GStreamer's Gst.parse_launch() accepts and executes the injected syntax

**Injection Mechanism:**
The '!' character in GStreamer syntax links pipeline elements. By including '!' in the STUN server parameter, the attacker breaks out of the intended webrtcbin property value and injects additional elements:

Normal: `stun-server=stun://google.com:19302`
Injected: `stun-server=stun://google.com:19302 ! fakesink location=/tmp/pwned`

GStreamer parses this as:
- webrtcbin with stun-server property set to "stun://google.com:19302"
- Link to new element: fakesink
- fakesink property: location=/tmp/pwned

**Attack Vectors:**

1. **QR Code Injection:** Android app accepts STUN parameter from QR codes without validation
2. **Signaling Message:** Signaling server messages can update configuration
3. **Configuration File:** Saved settings can be tampered with
4. **Command Line:** If STUN server can be set via command-line arguments

**GStreamer Elements Available for Exploitation:**
- fakesink: Write to arbitrary files
- udpsink: Exfiltrate data via UDP
- souphttpsrc: Make HTTP requests (SSRF)
- filesrc: Read files from filesystem
- identity: Manipulate buffer data
- queue: Buffer manipulation for complex pipelines

## Remediation

Implement comprehensive input validation and output encoding for the STUN server parameter:

**1. Add Input Validation Function (webrtc_streamer.py):**

```python
import re

def validate_stun_server(stun_server: str) -> str:
    """
    Validate and sanitize STUN server URL to prevent GStreamer injection.
    
    Args:
        stun_server: STUN server URL from configuration
        
    Returns:
        Sanitized STUN server URL
        
    Raises:
        ValueError: If STUN server format is invalid or contains dangerous characters
    """
    if not stun_server:
        raise ValueError("STUN server cannot be empty")
    
    if not isinstance(stun_server, str):
        raise ValueError("STUN server must be a string")
    
    # Strict format validation: stun://hostname:port
    pattern = r'^stun://[a-zA-Z0-9][a-zA-Z0-9.-]*:[0-9]{1,5}$'
    
    if not re.match(pattern, stun_server):
        raise ValueError(
            f"Invalid STUN server format: {stun_server}. "
            "Expected format: stun://hostname:port"
        )
    
    # Block GStreamer pipeline special characters
    forbidden_chars = ['!', '|', '&', ';', '$', '`', '(', ')', '{', '}']
    
    for char in forbidden_chars:
        if char in stun_server:
            raise ValueError(
                f"STUN server contains forbidden character: '{char}'. "
                "This character is not allowed in STUN server URLs."
            )
    
    # Additional security: enforce maximum length
    if len(stun_server) > 256:
        raise ValueError("STUN server URL too long (max 256 characters)")
    
    return stun_server
```

**2. Modify Pipeline Construction (webrtc_streamer.py lines 564, 587):**

```python
# VULNERABLE CODE (line 564):
# pipeline_str = f'''
#     webrtcbin name=webrtc bundle-policy=max-bundle stun-server={self.config.stun_server}
#     ...
# '''

# SECURE CODE:
# Validate STUN server before pipeline construction
try:
    validated_stun = validate_stun_server(self.config.stun_server)
except ValueError as e:
    logger.error(f"Invalid STUN server configuration: {e}")
    raise

# Properly escape and quote the parameter for GStreamer
escaped_stun = validated_stun.replace('"', '\\\\"')

pipeline_str = f'''
    webrtcbin name=webrtc bundle-policy=max-bundle stun-server="{escaped_stun}"
    {capture_src}
    ! videoconvert
    ! videoscale
    ! videorate
    ! video/x-raw,width={self.config.width},height={self.config.height},framerate={self.config.fps}/1
    ! queue max-size-buffers=2 leaky=downstream
    ! {video_enc}
    ! queue max-size-time=100000000 leaky=downstream
    ! webrtc.
    {audio_pipeline}
'''
```

**3. Add STUN Server Whitelist Configuration:**

```python
class SecurityConfig:
    """Security configuration for streaming"""
    
    # Whitelist of allowed STUN servers
    ALLOWED_STUN_SERVERS = [
        "stun://stun.l.google.com:19302",
        "stun://stun1.l.google.com:19302",
    ]
    
    @staticmethod
    def is_stun_allowed(stun_server: str) -> bool:
        """Check if STUN server is in allowed list"""
        return stun_server in SecurityConfig.ALLOWED_STUN_SERVERS

# Add validation check:
if not SecurityConfig.is_stun_allowed(validated_stun):
    logger.warning(f"STUN server not in whitelist: {validated_stun}")
    raise ValueError(f"STUN server not allowed: {validated_stun}")
```

**4. Enable STUN Server Configuration Validation on Android:**

```kotlin
// Validate STUN server from QR codes
fun validateStunServer(stunServer: String): Boolean {
    val pattern = Regex("^stun://[a-zA-Z0-9.-]+:[0-9]{1,5}$")
    return pattern.matches(stunServer) && 
           !stunServer.contains(Regex("[!|&;`$(){}"))
}

// In QR code parsing:
if (!validateStunServer(stunServer)) {
    Log.e(TAG, "Invalid STUN server in QR code")
    return
}
```

**5. Defense in Depth:**
- Log all STUN server configuration changes with user attribution
- Alert on suspicious STUN server values
- Rate limit STUN server changes
- Use GStreamer sandboxing (bubblewrap, flatpak) to restrict filesystem access
- Consider using a pre-compiled list of trusted STUN servers only

