# Resource Exhaustion via Shared Memory Leaks in X11 Screen Capture

**ID:** vuln-0009
**Severity:** MEDIUM
**Found:** 2026-01-26 04:28:46 UTC
**Target:** https://github.com/MrVanguardia/streamlinux
**Endpoint:** x11_capture.cpp:425-432
**CVSS:** 6.5

## Description

A medium severity denial-of-service vulnerability exists in X11 screen capture where shared memory segments are not properly cleaned up during configuration changes, allowing an attacker to exhaust system shared memory resources through repeated parameter modifications.

## Impact

Successful exploitation allows:
- **Shared Memory Exhaustion DoS**: Repeated config changes leak SHM segments
- **Service Disruption**: New streaming sessions cannot allocate memory
- **System Impact**: Affects other applications using SHM
- **Permanent DoS**: Requires reboot to recover leaked segments

Business Impact:
- Streaming service becomes unavailable
- System resource exhaustion affecting other processes
- No automatic recovery (manual intervention or reboot required)
- Service disruption persists after attack stops

Attack Vector: Network (control channel parameter manipulation)

## Technical Analysis

The vulnerability exists in `/workspace/streamlinux/linux-host/src/capture/x11_capture.cpp` at lines 425-432 in the `update_config()` method:

```cpp
Result<void> X11Capture::update_config(const CaptureConfig& config) {
    bool was_running = m_running;
    
    if (was_running) {
        stop();
    }
    
    // Update config
    m_config = config;
    
    // Reinitialize SHM if resolution changed
    if (m_shm_data) {
        shmdt(m_shm_data);  // Detach from SHM
        m_shm_data = nullptr;
    }
    if (m_shm_id >= 0) {
        shmctl(m_shm_id, IPC_RMID, nullptr);  // Mark SHM for removal
        m_shm_id = -1;
    }
    
    if (auto result = init_shm(); !result) {  // ← FAILS HERE
        return result;  // LEAK: Previous SHM already marked IPC_RMID but not actually freed yet
    }
    // ...
}
```

**Root Cause Analysis:**

1. **Manual Resource Management**: SHM cleanup is manual without RAII patterns
2. **Error Path Leak**: If `init_shm()` fails after cleanup, the old SHM segment is lost
3. **No Rollback**: Once `shmctl(IPC_RMID)` is called, the segment is marked for deletion but not actually freed until all processes detach
4. **Exception Unsafe**: No exception safety guarantees in C++ code

**Attack Scenario:**

An attacker sends rapid `set_resolution` commands via the control channel:
```
for (int i = 0; i < 100; i++) {
    send_control("set_resolution", {width: 3840, height: 2160});
    // Each triggers update_config()
    // If any init_shm() fails (e.g., out of memory), SHM leaks
}
```

**Resource Impact:**
- Each 4K SHM segment: `3840 * 2160 * 4 = 31,662,080` bytes (~32 MB)
- 100 leaked segments: `100 * 32 MB = 3.2 GB`
- System limit typically in `/proc/sys/kernel/shmmax`
- Once limit hit: No new SHM allocations possible

**Vulnerable Code Flow:**
```
Control Message → on_parameters_changed()
                → update_config()
                → stop() + shmdt() + shmctl(IPC_RMID)  // Old SHM marked for removal
                → init_shm()  // NEW allocation attempt
                → FAILS (e.g., shmget() returns -1)
                → RETURN ERROR
                → Old SHM segment leaked (marked for removal but process died before detach)
```

The issue is exacerbated by the fact that `shmctl(IPC_RMID)` only marks the segment for removal. The actual memory isn't freed until all attached processes call `shmdt()`. If the process crashes or errors out between marking and reattaching, the leak occurs.

## Remediation

1. **Implement RAII for Shared Memory** (Critical Fix):
   - Create SHMSegment wrapper class with proper destructor
   - Use move semantics for ownership transfer
   - Ensure automatic cleanup on errors

2. **Fix Error Handling**:
   - Ensure cleanup happens before new allocation attempt
   - Use RAII pattern to guarantee cleanup on all paths
   - Never call `shmctl(IPC_RMID)` until after `shmdt()` and new allocation succeeds

3. **Add Rate Limiting**:
   - Limit configuration changes to 1 per second
   - Implement exponential backoff on failures
   - Add maximum reconfiguration rate

4. **Resource Monitoring**:
   - Track SHM usage per session
   - Implement global SHM quota
   - Reject operations if SHM usage too high

5. **Validation**:
   - Validate resolution parameters before attempting reinit
   - Clamp resolution to reasonable bounds
   - Reject changes that would require unrealistic SHM sizes

Code Fix:
```cpp
// Add RAII wrapper class
class SharedMemorySegment {
    int m_shm_id = -1;
    void* m_data = nullptr;
    size_t m_size = 0;
    
public:
    SharedMemorySegment() = default;
    ~SharedMemorySegment() {
        cleanup();
    }
    
    // Move constructor/assignment
    SharedMemorySegment(SharedMemorySegment&& other) noexcept {
        m_shm_id = other.m_shm_id;
        m_data = other.m_data;
        m_size = other.m_size;
        other.m_shm_id = -1;
        other.m_data = nullptr;
    }
    
    void cleanup() {
        if (m_data) {
            shmdt(m_data);
            m_data = nullptr;
        }
        if (m_shm_id >= 0) {
            shmctl(m_shm_id, IPC_RMID, nullptr);
            m_shm_id = -1;
        }
    }
    // ... other methods
};

// In X11Capture::update_config()
Result<void> X11Capture::update_config(const CaptureConfig& config) {
    auto old_shm = std::move(m_shm_segment);  // Take ownership
    m_config = config;
    
    auto result = init_shm();  // If this fails, old_shm auto-destroyed
    if (!result) {
        return result;
    }
    
    // old_shm destroyed here
    return {};
}
```

