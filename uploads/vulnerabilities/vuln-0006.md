# Integer Overflow in Audio Sample Calculation Causes Buffer Overflow

**ID:** vuln-0006
**Severity:** HIGH
**Found:** 2026-01-26 04:27:11 UTC
**Target:** https://github.com/MrVanguardia/streamlinux
**Endpoint:** pipewire_audio.cpp:64-74
**CVSS:** 8.8

## Description

A critical integer overflow vulnerability exists in PipeWire audio capture where sample count calculations from untrusted audio buffer metadata can overflow, leading to incorrect memory allocation sizes and buffer overflow vulnerabilities in subsequent memcpy operations.

## Impact

Successful exploitation allows:
- **Buffer Overflow**: Integer overflow causes `total_samples` to wrap to small value
- **Memory Corruption**: memcpy writes beyond allocated buffer boundaries
- **Potential Remote Code Execution**: Controlled buffer overflow may allow RCE
- **Denial of Service**: Process crashes from invalid memory access

Business Impact:
- System compromise through audio stream exploitation
- Service interruption and crashes
- Potential privilege escalation
- Complete streaming functionality disruption

Attack Vector: Network (malicious PipeWire audio stream)

## Technical Analysis

The vulnerability exists in `/workspace/streamlinux/linux-host/src/audio/pipewire_audio.cpp` at lines 64-74:

```cpp
uint32_t n_samples = buf->datas[0].chunk->size / sizeof(float) / impl->config.channels;
AudioFrame frame;
frame.sample_rate = impl->config.sample_rate;
frame.channels = impl->config.channels;
frame.samples_per_channel = n_samples;
frame.pts = get_monotonic_pts();

size_t total_samples = n_samples * impl->config.channels;  // OVERFLOW!
frame.data.resize(total_samples);
std::memcpy(frame.data.data(), data, total_samples * sizeof(float));
```

**Root Cause Analysis:**

1. **Untrusted Input**: `buf->datas[0].chunk->size` comes from PipeWire stream, which can be controlled by an attacker.

2. **No Overflow Check**: The multiplication `n_samples * impl->config.channels` has no bounds checking for integer overflow.

3. **32-bit Vulnerability**: On 32-bit systems or with specific channel counts, this multiplication overflows:

**Attack Scenario:**

Normal operation:
- `chunk->size = 65536` bytes
- `channels = 2`
- `n_samples = 65536 / 4 / 2 = 8192`
- `total_samples = 8192 * 2 = 16384`
- Allocates: `16384 * 4 = 65536` bytes ✓

Malicious exploitation:
- Attacker crafts `chunk->size = 4294967292` (near UINT32_MAX)
- Attacker sets `channels = 65535` (via config or stream metadata)
- `n_samples = 4294967292 / 4 / 65535 = 16383` (rounded down)
- `total_samples = 16383 * 65535 = 107370905` (on 32-bit: OVERFLOWS)
- If overflow wraps to small value (e.g., 1000):
  - `resize(1000)` allocates only 4000 bytes
  - `memcpy` attempts to copy `107370905 * 4 = 429MB`
  - Writes 429MB into 4KB buffer → BUFFER OVERFLOW

**Exploitation Prerequisites:**
- Attacker can send malicious PipeWire audio streams
- Attacker can influence or guess channel count configuration
- 32-bit system or specific channel values causing overflow

The vulnerability stems from classic integer arithmetic overflow pattern where multiplication of untrusted values without overflow checks leads to memory corruption.

## Remediation

1. **Add Overflow Detection** (Critical - Immediate Fix):
   - Check for integer overflow before multiplication
   - Use `__builtin_mul_overflow` or manual bounds check
   - Reject frames that would cause overflow

2. **Validate Channel Count**:
   - Clamp channels to reasonable range (1-8 typical, max 32)
   - Reject unreasonably large channel counts

3. **Safe Copy Operation**:
   - Use `std::min()` for actual copy size
   - Verify buffer sizes match expectations
   - Add bounds checking

4. **64-bit Safe**:
   - Ensure size calculations use 64-bit on all platforms
   - Consider using `uint64_t` for intermediate calculations

Code Fix:
```cpp
// In pipewire_audio.cpp:64-74 (around line 72)
uint32_t n_samples = buf->datas[0].chunk->size / sizeof(float) / impl->config.channels;

// Validate channel count
if (impl->config.channels == 0 || impl->config.channels > 32) {
    pw_stream_queue_buffer(impl->stream, b);
    return;  // Invalid channel count
}

// Check for integer overflow
if (n_samples > SIZE_MAX / impl->config.channels) {
    pw_stream_queue_buffer(impl->stream, b);
    return;  // Would overflow
}

size_t total_samples = n_samples * impl->config.channels;
size_t actual_size = buf->datas[0].chunk->size / sizeof(float);

frame.data.resize(total_samples);
if (buf->datas[0].data) {
    // Safe copy: don't exceed available data
    std::memcpy(frame.data.data(), data, 
                std::min(total_samples * sizeof(float), 
                         (size_t)buf->datas[0].chunk->size));
}
```

5. **Additional Hardening**:
   - Add rate limiting for audio frames
   - Monitor for suspicious frame patterns
   - Implement frame size quotas

