# Control Channel Missing Authentication and Input Validation

**ID:** vuln-0005
**Severity:** CRITICAL
**Found:** 2026-01-26 04:26:25 UTC
**Target:** /workspace/streamlinux/linux-host
**Endpoint:** src/control/control_channel.cpp</endpoint>
<parameter=method>WebRTC Data Channel</method>
<parameter=code_file>/workspace/streamlinux/linux-host/src/control/control_channel.cpp
**CVSS:** 10.0

## Description

A critical authentication bypass vulnerability exists in the WebRTC control channel implementation. The parse_message() function at control_channel.cpp:136-140 is implemented as a stub that does not actually parse or validate JSON control messages. Additionally, there are no authentication mechanisms to verify the source of control messages. Any connected WebRTC peer can send arbitrary control commands to manipulate streaming parameters without authorization.

## Impact

An attacker who can establish a WebRTC connection to the streaming server can completely control the streaming session without authentication. This allows:
1. Denial of Service via invalid resolution/bitrate parameters
2. System crashes through parameter-triggered bugs (e.g., integer overflow in shared memory)
3. Unauthorized modification of streaming quality and performance
4. Potential for remote code execution when combined with other vulnerabilities
5. Privilege escalation from unauthenticated to full control

The vulnerability is critical because:
- No authentication required for control messages
- Anyone who can connect to the WebRTC endpoint gains full control
- LAN discovery makes finding targets trivial
- Can chain with other bugs (like X11 overflow) for RCE
- No rate limiting or authorization checks exist

## Technical Analysis

The vulnerability exists in ControlChannel::process_message() at control_channel.cpp:27-80:

```cpp
void ControlChannel::process_message(const ControlMessage& msg) {
    if (!m_handler) return;
    
    switch (msg.type) {
        case ControlMessageType::SetResolution:
        case ControlMessageType::SetBitrate:
        case ControlMessageType::SetQuality:
        case ControlMessageType::SelectMonitor: {
            auto params = parse_message(msg.payload);  // LINE 43
            if (params) {
                StreamParameters stream_params;
                // TODO: Parse JSON payload  // LINE 47 - NOT IMPLEMENTED!
                m_handler->on_parameters_changed(stream_params);
            }
            break;
        }
        // ... other cases
    }
}
```

The parse_message() stub (lines 136-140):
```cpp
Result<void> ControlChannel::parse_message(const std::string& json) {
    // Simple JSON parsing - in production use a proper JSON library
    (void)json;  // IGNORES INPUT COMPLETELY!
    return {};     // ALWAYS RETURNS SUCCESS!
}
```

Security issues:
1. parse_message() ignores JSON payload entirely
2. No validation of numeric parameters
3. No authentication of message source
4. No authorization check for control operations
5. Empty stream_params used (contains default/uninitialized values)
6. Any peer connected via WebRTC can send commands
7. No rate limiting on control messages
8. No cryptographic signature verification

Attack vectors:
- Direct WebRTC connection to open port
- LAN discovery broadcast
- MitM of WebRTC signaling
- Modified Android client
- Network scanning for vulnerable instances

## Code Analysis

**Changes:**
```diff
--- a/src/control/control_channel.cpp
+++ b/src/control/control_channel.cpp
@@ -136,5 +136,31 @@ std::string ControlChannel::build_json(const std::string& type, const std::string& payload) {
     
 Result<void> ControlChannel::parse_message(const std::string& json) {
-    // Simple JSON parsing - in production use a proper JSON library
-    (void)json;
-    return {};
+    // Secure JSON parsing with validation
+    try {
+        auto json = nlohmann::json::parse(json_str);
+        
+        // Validate required fields
+        if (!json.contains("payload") || !json["payload"].is_object()) {
+            return std::unexpected(Error{ErrorCode::InvalidArgument,
+                "Missing or invalid payload"});
+        }
+        
+        auto& payload = json["payload"];
+        
+        // Validate resolution parameters
+        if (payload.contains("width")) {
+            if (!payload["width"].is_number_unsigned()) {
+                return std::unexpected(Error{ErrorCode::InvalidArgument,
+                    "width must be unsigned integer"});
+            }
+            uint32_t width = payload["width"];
+            if (width > 7680 || width == 0) {
+                return std::unexpected(Error{ErrorCode::InvalidArgument,
+                    "width out of valid range (1-7680)"});
+            }
+        }
+        
+        // Additional validation for height, bitrate, fps, monitor_id
+        
+        return {};
+    } catch (const nlohmann::json::exception& e) {
+        return std::unexpected(Error{ErrorCode::InvalidArgument,
+            std::format("JSON parse error: {}", e.what())});
+    }
 }
```

## Remediation

1. Implement proper JSON parsing with validation:
   ```cpp
   #include <nlohmann/json.hpp>
   
   Result<void> ControlChannel::parse_message(const std::string& json_str) {
       try {
           auto json = nlohmann::json::parse(json_str);
           
           // Validate type field
           if (!json.contains("type")) {
               return std::unexpected(Error{ErrorCode::InvalidArgument, "Missing type"});
           }
           
           // Validate payload structure
           if (json.contains("payload")) {
               auto& payload = json["payload"];
               
               // Validate resolution
               if (payload.contains("width")) {
                   uint32_t width = payload["width"];
                   if (width > 7680 || width == 0) {
                       return std::unexpected(Error{ErrorCode::InvalidArgument, "Invalid width"});
                   }
               }
               // Similar for height, bitrate, etc.
           }
           return {};
       } catch (const nlohmann::json::exception& e) {
           return std::unexpected(Error{ErrorCode::InvalidArgument, e.what()});
       }
   }
   ```

2. Add authentication to control channel:
   - Generate shared secret during pairing
   - Sign all control messages with HMAC-SHA256
   - Verify signature before processing commands
   - Reject unsigned/invalidly signed messages

3. Add authorization checks:
   - Only authenticated peer can send control commands
   - Differentiate between viewer and controller roles
   - Require explicit permission for parameter changes

4. Add rate limiting:
   - Limit control messages per second
   - Drop excessive messages
   - Alert on suspicious patterns

5. Implement proper parameter validation:
   - Min/max bounds for all numeric values
   - Type checking
   - Sanity checks (e.g., resolution within monitor limits)

6. Add comprehensive logging:
   - Log all control messages
   - Log failures and rejections
   - Enable security auditing

