# X11 Shared Memory Integer Overflow Leading to Buffer Overflow

**ID:** vuln-0001
**Severity:** HIGH
**Found:** 2026-01-26 04:25:12 UTC
**Target:** /workspace/streamlinux/linux-host
**Endpoint:** src/capture/x11_capture.cpp</endpoint>
<parameter=method>Capture
**CVSS:** 7.8

## Description

A critical integer overflow vulnerability exists in the X11 screen capture implementation when calculating shared memory buffer sizes. The vulnerable code at x11_capture.cpp:86 performs the calculation `m_shm_size = width * height * 4` without overflow checking. When large resolution values are provided, the multiplication overflows the 32-bit unsigned integer, resulting in a significantly smaller shared memory allocation than required. Subsequent memcpy operations then overflow the allocated buffer, corrupting heap memory and potentially leading to remote code execution.

## Impact

An attacker who can influence the capture resolution (via command-line arguments, configuration files, or control messages) can trigger this integer overflow. This results in:
1. Undersized shared memory allocation via shmget()
2. X11 server writing more data than allocated
3. memcpy() reading beyond buffer boundaries (heap buffer overflow)
4. Memory corruption leading to application crash
5. Potential for arbitrary code execution if memory layout can be controlled

The vulnerability is particularly dangerous because:
- The application runs with user-level X11 permissions
- Heap corruption can lead to data leak or code execution
- Screen capture involves handling sensitive visual data
- No bounds checking exists between allocation and use

## Technical Analysis

The vulnerability occurs in X11Capture::init_shm() at line 86 of x11_capture.cpp:

```cpp
// Vulnerable code
uint32_t width = m_config.region.width;
uint32_t height = m_config.region.height;
m_shm_size = width * height * 4;  // INTEGER OVERFLOW
m_shm_id = shmget(IPC_PRIVATE, m_shm_size, IPC_CREAT | 0600);
```

The overflow scenarios:
- Normal 1080p: 1920 × 1080 × 4 = 8,294,400 bytes (safe)
- 65535 × 65535 × 4 = 17,179,344,900 (expected), but overflows to 4,294,443,012
- 100000 × 100000 × 4 = 40,000,000,000 (expected), but overflows to 1,345,294,336
- 65536 × 65536 × 4 overflows to 0 (zero-byte allocation!)

Later in capture_shm() at line 320:
```cpp
size_t data_size = width * height * 4;  // Also overflows
frame.data.resize(data_size);
std::memcpy(frame.data.data(), m_shm_data, data_size);  // BUFFER OVERFLOW
```

The memcpy reads more bytes than were allocated, causing heap corruption.

Root causes:
1. No overflow checking before multiplication
2. No validation that calculated size matches expected size
3. No bounds checking in memcpy operation
4. uint32_t too small for large resolution calculations
5. Trusted configuration values without validation

## Code Analysis

**File:** /workspace/streamlinux/linux-host/src/capture/x11_capture.cpp

**Changes:**
```diff
--- a/src/capture/x11_capture.cpp
+++ b/src/capture/x11_capture.cpp
@@ -83,7 +83,14 @@ Result<void> X11Capture::init_shm() {
     if (width == 0) width = m_screen->width_in_pixels;
     if (height == 0) height = m_screen->height_in_pixels;
     
-    // 4 bytes per pixel (BGRA)
-    m_shm_size = width * height * 4;
+    // 4 bytes per pixel (BGRA) - SAFE VERSION
+    uint64_t expected_size = (uint64_t)width * height * 4;
+    constexpr uint64_t MAX_SHM_SIZE = 256ULL * 1024ULL * 1024ULL; // 256MB max
+    
+    if (expected_size > MAX_SHM_SIZE) {
+        return std::unexpected(Error{ErrorCode::InvalidArgument,
+            "Resolution too large: would exceed maximum shared memory size"});
+    }
+    
+    m_shm_size = static_cast<uint32_t>(expected_size);
```

## Remediation

1. Add overflow checking before size calculation:
   ```cpp
   uint64_t expected_size = (uint64_t)width * height * 4;
   if (expected_size > UINT32_MAX || expected_size > MAX_SHM_SIZE) {
       return std::unexpected(Error{ErrorCode::InvalidArgument, "Resolution too large"});
   }
   m_shm_size = static_cast<uint32_t>(expected_size);
   ```

2. Validate configuration values early:
   - Maximum reasonable resolution (e.g., 7680×4320 for 8K)
   - Reject resolutions larger than X11 screen dimensions
   - Sanity check width/height in CLI parser and config manager

3. Use safe integer operations:
   - Use __builtin_umulll_overflow() or similar
   - Or perform multiplication in uint64_t then downcast with check

4. Add bounds checking to memcpy:
   ```cpp
   if (data_size > m_shm_size) {
       return std::unexpected(Error{ErrorCode::CaptureReadFailed, "Size mismatch"});
   }
   ```

5. Consider using size_t for all buffer sizes instead of uint32_t

6. Add comprehensive unit tests for edge cases

