# Untrusted Buffer Size Causes Memory Corruption in Wayland Screen Capture

**ID:** vuln-0002
**Severity:** HIGH
**Found:** 2026-01-26 04:25:47 UTC
**Target:** https://github.com/MrVanguardia/streamlinux
**Endpoint:** wayland_capture.cpp:609-611
**CVSS:** 8.3

## Description

A critical memory safety vulnerability exists in the Wayland screen capture implementation where untrusted buffer sizes from PipeWire are used directly for memory allocation and data copying without validation. An attacker who can send malicious PipeWire streams or corrupt the PipeWire metadata can cause memory exhaustion, out-of-bounds reads, or potentially achieve remote code execution.

## Impact

Successful exploitation allows:
- **Memory Exhaustion DoS**: Attacker sends frames with enormous size fields causing allocation of gigabytes of RAM, triggering OOM killer
- **Out-of-Bounds Memory Access**: Attacker supplies size larger than actual buffer, causing memcpy to read from unmapped memory
- **Potential Remote Code Execution**: Corrupted frame metadata could lead to controlled memory corruption in subsequent processing

Business Impact:
- Complete denial of service for streaming service
- System instability or crashes
- Potential privilege escalation if RCE achieved
- Information disclosure through error messages or memory reads

Attack Vector: Network (malicious PipeWire stream or compromised PipeWire daemon)

## Technical Analysis

The vulnerability exists in `/workspace/streamlinux/linux-host/src/capture/wayland_capture.cpp` at lines 609-611:

```cpp
size_t data_size = buf->datas[0].chunk->size;  // UNTRUSTED SOURCE
frame.data.resize(data_size);
std::memcpy(frame.data.data(), buf->datas[0].data, data_size);
```

**Root Cause Analysis:**

1. **No Upper Bound Validation**: `data_size` comes directly from `buf->datas[0].chunk->size`, which is user-controlled via the PipeWire stream. There is no maximum size check.

2. **Trust in PipeWire Metadata**: The code assumes PipeWire provides accurate metadata, but a compromised PipeWire daemon or malicious stream can provide arbitrary values.

3. **Memory Allocation Without Checks**: `frame.data.resize(data_size)` directly allocates memory based on untrusted input, allowing allocation of gigabytes with a single frame.

4. **Unsafe Copy Operation**: `std::memcpy` copies `data_size` bytes without verifying that `buf->datas[0].data` actually contains that many bytes.

**Attack Scenarios:**

**Scenario 1 - Memory Exhaustion:**
- Attacker sends PipeWire frame with `chunk->size = 10GB`
- `resize(10737418240)` allocates 10GB RAM
- Process is killed by OOM, causing DoS

**Scenario 2 - Out-of-Bounds Read:**
- Attacker sends `chunk->size = 0xFFFFFFFF`
- Buffer pointer valid but only contains 4KB
- `memcpy` reads 4GB from 4KB buffer
- Segfault or reads unmapped memory
- Potential information disclosure via crash dumps

**Scenario 3 - Integer Overflow:**
- Attacker crafts size to cause overflow in resize
- On 32-bit systems or with specific compiler optimizations
- Leads to buffer overflow in subsequent operations

The PipeWire stream data comes from an untrusted source (network/local attacker) and the code lacks any validation before using it for memory operations.

## Remediation

1. **Add Input Validation** (Critical - Immediate Fix):
   - Add maximum size limit for frame buffers (e.g., 4K HDR = 67MB)
   - Validate `data_size` before calling `resize()`
   - Reject frames exceeding reasonable limits

2. **Size Consistency Check**:
   - Calculate expected size: `expected = width * height * bytes_per_pixel`
   - Verify `data_size â‰ˆ expected` (allow small padding)
   - Reject frames with major size mismatches

3. **Bounds Verification**:
   - Verify `buf->datas[0].data` pointer validity
   - Ensure `data_size <= actual buffer capacity`
   - Use `std::min(data_size, available_size)` for safe copy

4. **Error Handling**:
   - Return error instead of crashing on invalid sizes
   - Log suspicious frames for security monitoring
   - Disconnect stream that sends invalid data

5. **Defense in Depth**:
   - Add rate limiting for frame sizes
   - Monitor memory usage per stream
   - Implement quotas for buffer allocations

Code Fix:
```cpp
// In wayland_capture.cpp:609-611
const size_t MAX_FRAME_SIZE = 67108864;  // 4K RGBA = 64MB

size_t data_size = buf->datas[0].chunk->size;

// Validate size
if (data_size == 0 || data_size > MAX_FRAME_SIZE) {
    pw_stream_queue_buffer(m_pw_stream, b);
    return;  // Skip invalid frame
}

// Verify against dimensions
uint32_t expected_size = m_video_format.info.raw.size.width * 
                        m_video_format.info.raw.size.height * 4;
if (data_size > expected_size * 2) {  // Allow 2x padding
    pw_stream_queue_buffer(m_pw_stream, b);
    return;
}

frame.data.resize(data_size);
if (buf->datas[0].data) {
    std::memcpy(frame.data.data(), buf->datas[0].data, 
                std::min(data_size, (size_t)buf->datas[0].maxsize));
}
```

