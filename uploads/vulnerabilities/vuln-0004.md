# Path Traversal and Arbitrary File Access in StreamLinux Config Management

**ID:** vuln-0004
**Severity:** HIGH
**Found:** 2026-01-26 04:26:22 UTC
**Target:** https://github.com/MrVanguardia/streamlinux (linux-host component)
**Endpoint:** /workspace/streamlinux/linux-host/src/cli/config_manager.cpp
**Method:** file operations
**CVSS:** 8.8

## Description

Multiple critical path traversal vulnerabilities were discovered in the StreamLinux Linux Host component's configuration file management system. The vulnerabilities allow unprivileged users to read arbitrary files, write to arbitrary locations, and probe the filesystem structure.

The application accepts user-supplied file paths via the --config command-line parameter and environment variables (XDG_CONFIG_HOME, HOME) without proper validation or sanitization. This enables attackers to:

1. Read sensitive system files (passwords, SSH keys, credentials)
2. Write arbitrary content to sensitive locations
3. Create directories in unintended locations
4. Exploit symlink-based TOCTOU race conditions
5. Probe filesystem structure for information disclosure

These vulnerabilities are particularly severe because the application is designed to capture screen/audio content, suggesting it runs with elevated privileges to access display servers and audio subsystems.

## Impact

Successful exploitation of these vulnerabilities allows:

**Confidentiality Impact: HIGH**
- Read sensitive system files (/etc/passwd, /etc/shadow)
- Access SSH private keys and authorized_keys
- Expose AWS credentials, database configs, API keys
- Read user's private configuration files
- Probe filesystem for sensitive files

**Integrity Impact: HIGH**
- Write arbitrary content to system files
- Inject malicious libraries via /etc/ld.so.preload
- Create malicious cron jobs for persistence
- Modify SSH authorized_keys for backdoor access
- Inject shell commands via ~/.bashrc
- Create directories in sensitive locations

**Availability Impact: HIGH**
- Denial of service via corrupt config files
- Fill disk space with malicious directories
- Crash application via malicious input

**Attack Scenarios:**
1. Local privilege escalation by writing to /etc/ld.so.preload
2. Credential theft by reading SSH keys and configuration files
3. Persistence mechanism via cron jobs or shell profile modification
4. Lateral movement by accessing other users' files
5. Information gathering via filesystem probing

## Technical Analysis

**Root Causes:**

1. **Unvalidated User Input** (config_manager.cpp:35)
   - CLI parameter --config directly used as file path
   - No sanitization or validation before file operations
   ```cpp
   std::string config_path = path.empty() ? get_default_path() : path;
   ```

2. **Environment Variable Trust** (config_manager.cpp:16-23)
   - XDG_CONFIG_HOME and HOME used without validation
   - Attackers can manipulate these variables via process environment
   ```cpp
   const char* xdg_config = std::getenv("XDG_CONFIG_HOME");
   const char* home = std::getenv("HOME");
   ```

3. **Arbitrary Directory Creation** (config_manager.cpp:59)
   - std::filesystem::create_directories() called on user-controlled paths
   - No validation of parent directory path
   ```cpp
   std::filesystem::create_directories(dir);
   ```

4. **TOCTOU Race Condition** (config_manager.cpp:37-42)
   - File existence check and file open are separate operations
   - Attacker can replace file with symlink between check and use
   ```cpp
   if (!std::filesystem::exists(config_path)) { ... }
   std::ifstream file(config_path);
   ```

5. **Backend Detector Path Issues** (backend_detector.cpp:42-45, 104)
   - WAYLAND_DISPLAY and XDG_RUNTIME_DIR used in path construction
   - No validation before filesystem operations
   ```cpp
   std::filesystem::path socket_path = runtime_dir;
   socket_path /= *wayland_display;
   if (std::filesystem::exists(socket_path)) { ... }
   ```

**Attack Vectors:**

- **Vector 1:** Direct path traversal via --config parameter
- **Vector 2:** Environment variable manipulation
- **Vector 3:** Symlink replacement attacks
- **Vector 4:** Directory traversal via parent references (../)
- **Vector 5:** Information disclosure via file existence checks

**Missing Security Controls:**

- No path canonicalization
- No symlink validation/resolution
- No allowlist of permitted directories
- No ownership/permission checks
- No chroot/sandboxing
- No input validation on file paths

## Remediation

1. **Implement Path Validation**
   - Add comprehensive input validation on all file paths
   - Use std::filesystem::canonical() to resolve symlinks and relative paths
   - Reject paths containing ".." sequences or absolute paths outside allowlist
   ```cpp
   std::filesystem::path validate_path(const std::string& user_path) {
       auto canonical = std::filesystem::canonical(user_path);
       auto allowed = std::filesystem::canonical("/home/user/.config");
       if (!canonical.string().starts_with(allowed.string())) {
           throw std::runtime_error("Path not allowed");
       }
       return canonical;
   }
   ```

2. **Restrict Configuration Locations**
   - Implement allowlist of permitted config directories
   - Only allow: ~/.config/streamlinux/, /etc/streamlinux/, $XDG_CONFIG_HOME/streamlinux/
   - Reject all other paths explicitly
   ```cpp
   bool is_config_path_allowed(const std::string& path) {
       std::vector<std::filesystem::path> allowed = {
           std::filesystem::path(getenv("HOME")) / ".config" / "streamlinux",
           "/etc/streamlinux"
       };
       // Check if path is within allowed directories
   }
   ```

3. **Validate Environment Variables**
   - Validate XDG_CONFIG_HOME and HOME before use
   - Fallback to safe defaults if suspicious values detected
   - Warn about non-standard environment variable values
   ```cpp
   std::string get_safe_config_home() {
       const char* xdg = getenv("XDG_CONFIG_HOME");
       if (xdg && xdg[0] != '/') {
           // Suspicious: not an absolute path
           return get_default_config_home();
       }
       if (xdg && std::filesystem::exists(xdg)) {
           return xdg;
       }
       return get_default_config_home();
   }
   ```

4. **Prevent Symlink Attacks**
   - Use O_NOFOLLOW flag when opening files (prevents following symlinks)
   - Resolve symlinks and validate the final target
   - Implement atomic file operations to prevent TOCTOU
   ```cpp
   int fd = open(path.c_str(), O_RDONLY | O_NOFOLLOW);
   if (fd == -1) {
       // Error - symlink detected or other issue
   }
   ```

5. **Add Permission Checks**
   - Verify file ownership before reading
   - Check directory permissions match expected values
   - Use umask to restrict created file permissions (0600 for configs)
   ```cpp
   void check_file_permissions(const std::string& path) {
       auto perms = std::filesystem::status(path).permissions();
       if (perms.owner_write != std::filesystem::perms::owner_write) {
           throw std::runtime_error("Unsafe permissions");
       }
   }
   ```

6. **Implement Sandboxing**
   - Use systemd sandboxing or chroot for isolation
   - Run with minimal required privileges (CAP_SYS_ADMIN for display access only)
   - Use seccomp filters to restrict syscalls
   - Enable user namespaces for privilege separation

7. **Add Comprehensive Logging**
   - Log all file access attempts
   - Alert on suspicious path operations
   - Audit configuration load/save operations
   ```cpp
   void log_config_access(const std::string& path, const std::string& operation) {
       syslog(LOG_WARNING, "Config %s: %s", operation.c_str(), path.c_str());
   }
   ```

8. **Implement Configuration File Validation**
   - Use a proper TOML parser library instead of custom implementation
   - Validate file content before parsing
   - Implement schema validation for config values
   - Sanitize all values read from config files

9. **Security Testing**
   - Add fuzzing tests for file path handling
   - Create unit tests for path validation functions
   - Test with malicious file paths and symlinks
   - Perform security audit of file I/O operations

10. **Documentation**
   - Document security model and assumptions
   - Warn users about running with elevated privileges
   - Provide secure configuration guidelines
   - Include security considerations in user manual

