# Server-Side Request Forgery (SSRF) via Unvalidated STUN/TURN Server Configuration

**ID:** vuln-0003
**Severity:** CRITICAL
**Found:** 2026-01-26 04:25:57 UTC
**Target:** /workspace/streamlinux/linux-gui
**Endpoint:** /workspace/streamlinux/linux-gui/streamlinux_gui.py
**Method:** N/A
**CVSS:** 9.6

## Description

A server-side request forgery (SSRF) vulnerability exists in the STUN/TURN server configuration settings. The application allows users to configure arbitrary STUN/TURN server URLs without any validation or sanitization, which can be exploited to force the application to make outbound connections to attacker-controlled or internal network destinations.

The vulnerability is present in the settings UI (lines 1929-1948 in streamlinux_gui.py) where users can enter custom STUN and TURN server addresses. These values are stored directly to the configuration file and subsequently used in WebRTC ICE negotiation without any validation of the URL format, hostname, or destination.

## Impact

Successful exploitation allows an attacker to:

1. **Internal Network Scanning**: By setting STUN/TURN servers to internal IP addresses (e.g., 192.168.x.x, 10.0.0.x, 127.0.0.1), an attacker can enumerate internal network services and port availability based on connection success/failure.

2. **Cloud Metadata Access**: In cloud environments, an attacker could potentially access instance metadata services by configuring STUN/TURN to link-local addresses (e.g., 169.254.169.254 for AWS).

3. **Data Exfiltration**: Attacker-controlled STUN/TURN servers could intercept WebRTC traffic, including session tokens, ICE candidates, and potentially encrypted media streams.

4. **Denial of Service**: Configuring malicious or unreachable STUN/TURN servers can prevent legitimate WebRTC connections from being established.

Business Impact:
- Compromise of internal network topology
- Potential access to sensitive cloud metadata and credentials
- Interception of streaming sessions and authentication tokens
- Service disruption

## Technical Analysis

The vulnerability stems from a lack of input validation and sanitization when processing STUN/TURN server configuration values.

**Vulnerable Code Path:**

1. **Configuration Input (streamlinux_gui.py:1929-1948)**:
```python
# STUN server - no validation
self.stun_row = Adw.EntryRow()
self.stun_row.set_title(_('pref_stun'))
self.stun_row.set_text(self.config.get('stun_server'))
self.stun_row.connect("changed", self._on_stun_changed)

def _on_stun_changed(self, row):
    self.config.set('stun_server', row.get_text())  # Direct storage, no validation
```

2. **Configuration Storage (streamlinux_gui.py:172-180)**:
```python
def _save(self):
    try:
        self.CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        with open(self.CONFIG_FILE, 'w') as f:
            json.dump(self._config, f, indent=2)  # Stored without validation
```

3. **WebRTC Usage (webrtc_streamer.py:86, StreamConfig)**:
```python
@dataclass
class StreamConfig:
    # ...
    stun_server: str = "stun://stun.l.google.com:19302"
    # Used directly in ICE negotiation
```

**Missing Security Controls:**
- No URL format validation (e.g., checking for valid stun:/turn: scheme)
- No hostname validation (could be IP address, domain name, or arbitrary string)
- No whitelist/blacklist of allowed STUN/TURN servers
- No restriction on private/reserved IP ranges (RFC 1918, link-local, loopback)
- No sanitization of special characters or protocol switching attempts

**Attack Scenarios:**
- Setting STUN to `stun:127.0.0.1:22` to probe local SSH
- Setting TURN to `turn:169.254.169.254:80` to access AWS metadata
- Setting STUN to `stun:attacker.com:3478` to redirect ICE negotiation

## Remediation

1. **Implement Strict URL Validation**:
   - Add validation function for STUN/TURN server URLs
   - Allow only stun: and turn: URI schemes
   - Validate hostname format according to RFC 1123
   - Reject any URLs with special characters or protocol switching attempts

2. **Block Private and Reserved IP Ranges**:
   - Parse hostname and resolve to IP address
   - Reject connections to:
     - 127.0.0.0/8 (loopback)
     - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 (private IPv4)
     - 169.254.0.0/16 (link-local/metadata)
     - 0.0.0.0/8 (this network)
   - Block IPv6 equivalents: ::1, fc00::/7, fe80::/10

3. **Implement Allowlist Approach**:
   - Provide a predefined list of trusted STUN/TURN servers
   - Require explicit user confirmation for custom servers
   - Consider making custom servers an advanced/developer-only feature

4. **Add Network Egress Controls**:
   - Configure firewall to block outbound connections from the application to internal ranges
   - Route all WebRTC traffic through a controlled proxy if necessary

5. **Add Logging and Alerting**:
   - Log all STUN/TURN server configuration changes
   - Alert on attempts to use internal/private addresses
   - Monitor for unusual connection patterns

**Example Validation Code**:
```python
import re
import socket
from urllib.parse import urlparse

def validate_stun_turn_url(url: str) -> bool:
    """Validate STUN/TURN server URL"""
    try:
        parsed = urlparse(url)
        
        # Allow only stun and turn schemes
        if parsed.scheme not in ['stun', 'stuns', 'turn', 'turns']:
            return False
        
        # Validate hostname
        if not parsed.hostname:
            return False
        
        # Block localhost variants
        if parsed.hostname in ['localhost', '127.0.0.1', '::1', '0.0.0.0']:
            return False
        
        # Resolve and block private IPs
        try:
            ip = socket.gethostbyname(parsed.hostname)
            if is_private_ip(ip):
                return False
        except socket.gaierror:
            pass
        
        return True
    except Exception:
        return False

def is_private_ip(ip: str) -> bool:
    """Check if IP is in private range"""
    try:
        # Simple check for private ranges
        parts = ip.split('.')
        if len(parts) != 4:
            return False
        first = int(parts[0])
        second = int(parts[1])
        
        # 10.0.0.0/8
        if first == 10:
            return True
        # 172.16.0.0/12
        if first == 172 and 16 <= second <= 31:
            return True
        # 192.168.0.0/16
        if first == 192 and second == 168:
            return True
        # 127.0.0.0/8
        if first == 127:
            return True
        # 169.254.0.0/16 (link-local/metadata)
        if first == 169 and second == 254:
            return True
        
        return False
    except ValueError:
        return False
```

