# Missing Frame Dimension Validation Causes Denial of Service in Video Encoder

**ID:** vuln-0010
**Severity:** MEDIUM
**Found:** 2026-01-26 04:30:25 UTC
**Target:** https://github.com/MrVanguardia/streamlinux
**Endpoint:** video_encoder.cpp:330-331, 367
**CVSS:** 5.5

## Description

A medium severity denial-of-service vulnerability exists in the FFmpeg video encoder where frame dimensions from untrusted capture sources are not validated before being passed to FFmpeg functions, allowing an attacker to cause crashes or system instability through crafted frame dimensions.

## Impact

Successful exploitation allows:
- **Denial of Service**: Invalid frame dimensions cause encoder crashes
- **Memory Exhaustion**: Extreme dimensions allocate excessive memory
- **System Instability**: Division by zero or invalid memory access in FFmpeg
- **Service Disruption**: Streaming service terminates and requires restart

Business Impact:
- Streaming service interruption
- System resource exhaustion
- Potential cascading failures to other processes
- No data compromise, but complete service disruption

Attack Vector: Local (compromise of capture component) or Network (if capture data can be manipulated)

## Technical Analysis

The vulnerability exists in `/workspace/streamlinux/linux-host/src/encoding/video_encoder.cpp` at lines 330-331 and 367:

```cpp
// Line 330-331: No dimension validation before sws_scale
Result<void> FFmpegVideoEncoder::convert_frame(const VideoFrame& src, AVFrame* dst) {
    // ... 
    sws_scale(m_sws_ctx, src_data, src_linesize, 0, src.height,  // ← src.height unvalidated
              dst->data, dst->linesize);
}

// Line 367: No validation before hardware transfer
if (av_hwframe_transfer_data(m_hw_frame, m_frame, 0) >= 0) {  // ← m_frame dimensions unvalidated
    m_hw_frame->pts = m_frame->pts;
    encode_frame = m_hw_frame;
}
```

**Root Cause Analysis:**

1. **No Dimension Validation**: Frame width and height are used directly from captured frames without any range checking
2. **Trust in Capture Sources**: Code assumes capture components provide valid dimensions
3. **FFmpeg Vulnerabilities**: Invalid dimensions can trigger bugs in FFmpeg's sws_scale and hardware transfer functions

**Attack Scenarios:**

**Scenario 1 - Zero Dimensions:**
- Attacker injects frame with `width=0, height=0`
- `sws_scale()` receives `src.height=0`
- Internal FFmpeg calculations divide by zero or dereference null pointers
- Result: Segmentation fault, encoder crash

**Scenario 2 - Extreme Dimensions:**
- Attacker injects frame with `width=65535, height=65535`
- `sws_scale()` allocates temporary buffers based on dimensions
- Buffer size: `65535 * 65535 * 4 = 17,179,869,184` bytes (~17 GB)
- System runs out of memory
- Result: OOM kill, system freeze

**Scenario 3 - Invalid Stride:**
- Attacker sets `stride < width * bytes_per_pixel`
- Example: `width=1920, stride=100`
- `sws_scale()` reads rows with incorrect spacing
- Reads from wrong memory locations
- Result: Out-of-bounds read, potential information disclosure

**Attack Vectors:**
- **Local**: Compromise PipeWire or X11 to inject crafted frames
- **Network**: If control channel allows frame injection or dimension manipulation
- **Configuration**: Use control channel to set extreme resolutions

The vulnerability stems from missing input validation at the boundary between capture and encoding components. Capture sources (X11, Wayland, PipeWire) are trusted to provide valid frame dimensions, but compromised capture daemons or network-based attacks could subvert this trust.

## Remediation

1. **Add Dimension Validation** (Critical Fix):
   - Validate width/height are non-zero
   - Impose maximum limits (e.g., 4096x4096)
   - Set minimum reasonable limits (e.g., 64x64)
   - Reject frames outside valid range

2. **Validate Stride**:
   - Verify `stride >= width * bytes_per_pixel`
   - Reject frames with invalid stride values
   - Account for padding but ensure safety

3. **Resource Limits**:
   - Apply system resource limits (setrlimit)
   - Monitor encoder memory usage
   - Kill encoder if it exceeds limits

4. **Configuration Bounds**:
   - Limit configured resolution to reasonable values
   - Validate config file values
   - Reject extreme values from control channel

Code Fix:
```cpp
// In video_encoder.h, add constants
class FFmpegVideoEncoder {
    static constexpr uint32_t MAX_WIDTH = 4096;
    static constexpr uint32_t MAX_HEIGHT = 4096;
    static constexpr uint32_t MIN_WIDTH = 64;
    static constexpr uint32_t MIN_HEIGHT = 64;
    // ...
};

// In video_encoder.cpp:336, add validation
Result<EncodedVideoFrame> FFmpegVideoEncoder::encode(const VideoFrame& frame) {
    if (!m_initialized) {
        return std::unexpected(Error{ErrorCode::NotInitialized});
    }
    
    // Validate frame dimensions
    if (frame.width == 0 || frame.height == 0) {
        return std::unexpected(Error{ErrorCode::EncodingFailed,
            "Frame dimensions cannot be zero"});
    }
    
    if (frame.width > MAX_WIDTH || frame.height > MAX_HEIGHT) {
        return std::unexpected(Error{ErrorCode::EncodingFailed,
            "Frame dimensions exceed maximum allowed"});
    }
    
    if (frame.width < MIN_WIDTH || frame.height < MIN_HEIGHT) {
        return std::unexpected(Error{ErrorCode::EncodingFailed,
            "Frame dimensions below minimum allowed"});
    }
    
    // Validate stride
    uint32_t expected_stride = frame.width * 4;
    if (frame.stride < expected_stride) {
        return std::unexpected(Error{ErrorCode::EncodingFailed,
            "Invalid frame stride - smaller than expected"});
    }
    
    // Continue with encoding...
}
```

