# SSL Certificate Validation Bypass Enables Complete WebSocket Session Hijacking

**ID:** vuln-0012
**Severity:** CRITICAL
**Found:** 2026-01-26 04:36:27 UTC
**Target:** https://github.com/MrVanguardia/streamlinux
**Endpoint:** /workspace/streamlinux/linux-gui/webrtc_streamer.py
**Method:** WebSocket
**CVSS:** 10.0

## Description

A critical SSL/TLS certificate validation bypass vulnerability exists in the StreamLinux Linux GUI application that completely disables certificate verification for WebSocket connections to the signaling server. The vulnerability allows trivial Man-in-the-Middle (MITM) attacks on the same network, enabling complete interception of all WebRTC signaling traffic, including session tokens, SDP offers/answers, ICE candidates, and peer identification data.

The vulnerability occurs in webrtc_streamer.py line 179 where ssl.CERT_NONE is passed to the WebSocket client configuration, effectively disabling all SSL/TLS certificate validation. This means the application will accept any certificate presented by a server, including self-signed certificates, expired certificates, or certificates for different hostnames.

An attacker on the same Local Area Network (LAN) can perform ARP spoofing, DNS spoofing, or other network-level attacks to redirect the victim's WebSocket connection to a malicious proxy server. The victim's StreamLinux client will accept the attacker's invalid certificate without any warning, allowing the attacker to intercept, view, and modify all signaling messages in real-time.

This vulnerability is particularly severe because WebRTC signaling messages contain sensitive session establishment data including SDP offers/answers with crypto keys, ICE candidates revealing network topology, session tokens and peer IDs for authentication, and host registration information. Once the signaling is compromised, an attacker can potentially hijack the WebRTC session, modify media streams, or inject malicious content.

## Impact

Successful exploitation of this vulnerability allows an attacker to:

1. **Complete Session Hijacking**: Intercept all WebRTC signaling messages, allowing the attacker to take over or inject into streaming sessions between the Linux host and Android clients.

2. **Credential and Token Theft**: Capture session tokens, peer IDs, and authentication credentials transmitted over the WebSocket connection.

3. **Network Topology Discovery**: Extract ICE candidates to discover the victim's internal network structure, IP addresses, and network topology.

4. **Crypto Key Exposure**: Access SRTP (Secure Real-time Transport Protocol) crypto keys from SDP messages, potentially allowing decryption of media streams.

5. **Session Manipulation**: Modify SDP offers/answers to downgrade encryption, redirect media streams through attacker-controlled relays, or inject malicious ICE candidates.

6. **Authentication Bypass**: Intercept and replay registration messages to impersonate legitimate hosts or clients.

**Business Impact**: Complete compromise of streaming session confidentiality and integrity, potential for unauthorized screen capture and remote access, network reconnaissance capabilities for lateral movement, privacy violation through interception of sensitive screen/audio content, and trust degradation in the application's security model.

**Exploitation Difficulty**: LOW - Requires only network position on same LAN and basic ARP spoofing tools.

## Technical Analysis

The vulnerability resides in the Linux GUI component (Python) which establishes a WebSocket connection to the signaling server for WebRTC coordination.

**Vulnerable Code Location**: `/workspace/streamlinux/linux-gui/webrtc_streamer.py` line 179

```python
self.ws_thread = threading.Thread(
    target=lambda: self.signaling_ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}),
    daemon=True
)
```

**Root Cause Analysis**: The `ssl.CERT_NONE` parameter completely disables SSL/TLS certificate validation in the websocket-client library. According to Python's ssl module documentation, ssl.CERT_NONE means "Ignore certificate errors and do not verify certificates" - this is the most insecure option and should never be used in production.

**Security Implications**:
1. **No Certificate Chain Validation**: The client doesn't verify that the certificate is signed by a trusted Certificate Authority (CA)
2. **No Hostname Verification**: The client doesn't check that the certificate's Common Name (CN) or Subject Alternative Names (SAN) match the server's hostname
3. **Accepts Invalid Certificates**: The client will accept self-signed certificates, expired certificates, certificates for different domains, certificates with invalid signatures, and revoked certificates (no CRL/OCSP checking)
4. **WebSocket Connection Exposure**: The WebSocket connection (typically on port 8443) carries all WebRTC signaling including registration messages with host identity, SDP offers/answers with crypto fingerprints, ICE candidates with IP addresses and network paths, and session tokens and peer IDs

**Attack Vector**: The vulnerability enables network-based MITM attacks through ARP spoofing (arpspoof, bettercap), DNS spoofing (dnsspoof, fake DNS responses), DHCP spoofing (rogue DHCP server), ICMP redirects, BGP route hijacking (for inter-network attacks), and compromised network infrastructure (routers, switches).

**Affected Components**:
1. `linux-gui/webrtc_streamer.py` - Host application WebSocket client
2. Signaling server communication - All signaling messages exposed
3. WebRTC session establishment - SDP and ICE candidates compromised
4. Android client - May be affected if it also lacks proper certificate validation

This is a fundamental security control failure that completely undermines the TLS security model.

## Remediation

IMMEDIATE REMEDIATION REQUIRED (Priority 0 - Critical):

**Step 1: Enable Proper Certificate Validation**

Replace the vulnerable code in `linux-gui/webrtc_streamer.py` line 179:

VULNERABLE CODE:
```python
self.ws_thread = threading.Thread(
    target=lambda: self.signaling_ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE}),
    daemon=True
)
```

FIXED CODE:
```python
self.ws_thread = threading.Thread(
    target=lambda: self.signaling_ws.run_forever(sslopt={"cert_reqs": ssl.CERT_REQUIRED}),
    daemon=True
)
```

**Step 2: Add Certificate Authority Bundle**

```python
import certifi

self.ws_thread = threading.Thread(
    target=lambda: self.signaling_ws.run_forever(sslopt={
        "cert_reqs": ssl.CERT_REQUIRED,
        "ca_certs": certifi.where(),
    }),
    daemon=True
)
```

Install certifi: `pip install certifi`

**Step 3: Implement Certificate Pinning (Best Security)**

```python
import hashlib
import ssl

PINNED_FINGERPRINT = "AA:BB:CC:DD:EE:FF:..."  # Extract from server cert

def verify_certificate(cert, hostname):
    if cert.get('subject', {}).get('commonName') != hostname:
        return False
    if cert.get('fingerprint', '') != PINNED_FINGERPRINT:
        return False
    return True

sslopt={
    "cert_reqs": ssl.CERT_REQUIRED,
    "ca_certs": "/path/to/ca-bundle.crt",
    "certfile": "/path/to/client.crt",
    "keyfile": "/path/to/client.key"
}
```

**Step 4: Add Hostname Verification**

```python
import ssl

context = ssl.create_default_context()
context.verify_mode = ssl.CERT_REQUIRED
context.check_hostname = True

sslopt={
    "cert_reqs": ssl.CERT_REQUIRED,
    "ca_certs": certifi.where(),
    "server_hostname": "your-signaling-server.com"
}
```

**Step 5: Add Certificate Validation Logging**

```python
import logging

logger = logging.getLogger('security')

try:
    self.signaling_ws.run_forever(sslopt={
        "cert_reqs": ssl.CERT_REQUIRED,
        "ca_certs": certifi.where()
    })
except ssl.SSLError as e:
    logger.error(f"Certificate validation failed: {e}")
    logger.error("Possible MITM attack detected!")
    raise
```

**Step 6: Testing the Fix**

Test that valid certificates are accepted and invalid certificates (self-signed, expired, wrong hostname) are rejected.

**Step 7: Security Code Review**

Review all WebSocket and SSL/TLS connections across the entire codebase for similar issues.

