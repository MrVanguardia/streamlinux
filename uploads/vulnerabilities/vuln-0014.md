# Token Authentication Bypass in StreamLinux Signaling Server

**ID:** vuln-0014
**Severity:** CRITICAL
**Found:** 2026-01-26 04:39:01 UTC
**Target:** https://github.com/MrVanguardia/streamlinux
**Endpoint:** /ws, /ws/signaling
**Method:** WebSocket upgrade (HTTP)
**CVSS:** 10.0

## Description

A critical authentication bypass vulnerability exists in the StreamLinux signaling server that allows unauthorized clients to connect to any room, intercept WebRTC signaling messages, and hijack streaming sessions.

The vulnerability is in hub.go line 664 where the token validation condition `if !isHost && hub.security.RequireToken && token != ""` only validates tokens when the token parameter is non-empty. This creates two bypass vectors:
1. Sending an empty token string: token=""
2. Omitting the token parameter completely

Both methods allow an attacker to bypass authentication entirely and access any streaming room.

## Impact

Successful exploitation allows an attacker to:

1. **Unauthorized Room Access**: Connect to any streaming room without valid authentication
2. **Session Hijacking**: Intercept WebRTC signaling messages (offer, answer, ICE candidates) between legitimate hosts and clients
3. **Peer Information Disclosure**: View information about all peers in a room including their device IDs and peer IDs
4. **Signaling Injection**: Inject malicious WebRTC signaling messages to disrupt or manipulate streaming sessions
5. **Man-in-the-Middle Attacks**: Position between host and client to modify or relay signaling data

This is especially dangerous in environments where:
- Streaming sensitive content (screen sharing with confidential data)
- Remote desktop access scenarios
- Multi-user environments where privacy is expected
- Corporate environments using StreamLinux for screen sharing

The vulnerability completely undermines the authentication mechanism intended to protect streaming sessions.

## Technical Analysis

The vulnerability stems from a logic error in the token validation code in `/workspace/streamlinux/signaling-server/internal/signaling/hub.go` at line 664.

**Vulnerable Code:**
```go
// Token validation for non-host connections (clients/viewers)
// Hosts register tokens, clients must provide valid tokens
isHost := clientType == "host"

if !isHost && hub.security.RequireToken && token != "" {
    if !hub.ValidateToken(token) {
        logger.Warn("Invalid token rejected",
            zap.String("remote", remoteAddr),
            zap.String("token", token[:min(8, len(token))]+"..."))
        http.Error(w, "Invalid or expired token", http.StatusUnauthorized)
        return
    }
    logger.Info("Token validated successfully", zap.String("remote", remoteAddr))
}
```

**Logic Flaw:**
The condition `token != ""` means token validation ONLY executes when a non-empty token is provided. This creates the bypass:

- If token is empty string (""): Condition evaluates to false, validation is skipped
- If token parameter is omitted: token == "" (default), validation is skipped
- Only if token has a value: Validation runs

The correct logic should be:
```go
if !isHost && hub.security.RequireToken {
    if token == "" || !hub.ValidateToken(token) {
        // Reject
    }
}
```

**Authentication Flow:**
1. Host connects and registers a token for their room
2. Clients are supposed to provide this token to join
3. The bypass allows clients to join without ever providing a valid token
4. The server treats them as authenticated clients

**Server Configuration:**
- Default security config sets `RequireToken: true` (hub.go:109)
- Despite this, the bypass works due to the logic flaw
- Rate limiting does not prevent the bypass (10 attempts/minute)

## Remediation

**IMMEDIATE REMEDIATION REQUIRED:**

**Fix the token validation logic in `/workspace/streamlinux/signaling-server/internal/signaling/hub.go` line 664:**

Vulnerable code:
```go
if !isHost && hub.security.RequireToken && token != "" {
    if !hub.ValidateToken(token) {
        http.Error(w, "Invalid or expired token", http.StatusUnauthorized)
        return
    }
}
```

Fixed code:
```go
// Token validation for non-host connections
isHost := clientType == "host"

if !isHost && hub.security.RequireToken {
    if token == "" {
        logger.Warn("Token missing for client connection",
            zap.String("remote", remoteAddr))
        http.Error(w, "Token required", http.StatusUnauthorized)
        return
    }
    if !hub.ValidateToken(token) {
        logger.Warn("Invalid token rejected",
            zap.String("remote", remoteAddr),
            zap.String("token", token[:min(8, len(token))]+"..."))
        http.Error(w, "Invalid or expired token", http.StatusUnauthorized)
        return
    }
    logger.Info("Token validated successfully", zap.String("remote", remoteAddr))
}
```

**Additional Security Hardening:**

1. **Enable host authentication**: Implement mutual TLS or pre-shared keys for hosts. Don't rely solely on `X-Client-Type` header (easily spoofed)

2. **Add connection logging and monitoring**: Log all connection attempts with full details. Alert on repeated authentication failures. Track and rate-limit by IP address more aggressively

3. **Implement proper session management**: Use cryptographically secure random tokens. Short token expiration (5 minutes is reasonable). One-time use tokens if possible

4. **Add WebSocket origin validation**: Currently `CheckOrigin()` always returns true (hub.go:188-201). Implement proper origin validation

5. **Secure HTTP endpoints**: Add authentication to `/rooms` and `/hosts` endpoints. These currently expose room information without authentication

**Testing the fix:**
1. Apply the patch
2. Restart the signaling server
3. Run the PoC script again - should be rejected with 401
4. Test with valid token - should succeed

**Verification:**
```bash
# After fix, this should fail with 401 Unauthorized:
python3 token_bypass_poc_v2.py --server 127.0.0.1:8080 --room test_room
```

