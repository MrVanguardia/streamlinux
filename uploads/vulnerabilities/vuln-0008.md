# Insecure File Permissions on Configuration Files Exposing Sensitive Settings

**ID:** vuln-0008
**Severity:** MEDIUM
**Found:** 2026-01-26 04:27:23 UTC
**Target:** /workspace/streamlinux/linux-gui
**Endpoint:** /workspace/streamlinux/linux-gui/streamlinux_gui.py
**Method:** N/A
**CVSS:** 6.8

## Description

The application stores sensitive configuration data including network settings, security preferences, and device information in JSON configuration files without enforcing restrictive file permissions. The settings.json file is created with default umask permissions (typically 644 - world-readable), allowing any user on the system to read sensitive configuration data.

While the authorized_devices.json file is protected with 0o600 permissions (user-only read/write), the main settings file lacks this protection despite containing equally sensitive information such as authentication tokens, device trust settings, and network configuration.

## Impact

Successful exploitation allows:

1. **Information Disclosure**: Any user on the system can read sensitive settings including:
   - Security preferences (token expiry, PIN requirements, auto-trust settings)
   - Network configuration (ports, STUN/TURN servers)
   - Device trust status
   - Streaming quality settings and preferences

2. **Privilege Escalation Enabler**: Leaked configuration details can help attackers understand the security posture and identify weaknesses to exploit in conjunction with other vulnerabilities.

3. **Privacy Violation**: Users' streaming preferences, device history, and trusted device list become visible to other users on shared systems.

Business Impact:
- Compromise of user privacy on multi-user systems
- Exposure of security configuration aiding targeted attacks
- Potential credential/token exposure if stored in future versions
- Violation of security best practices for sensitive data storage

## Technical Analysis

The vulnerability exists in the AppConfig class which manages persistent configuration storage.

**Vulnerable Code Path (streamlinux_gui.py:172-180)**:
```python
def _save(self):
    """Save configuration to file"""
    try:
        self.CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        with open(self.CONFIG_FILE, 'w') as f:
            json.dump(self._config, f, indent=2)
        print(f"Saved config to {self.CONFIG_FILE}")
    except Exception as e:
        print(f"Error saving config: {e}")
```

**Security Gap Analysis:**

1. **Missing os.chmod() Call**: Unlike SecurityManager which sets 0o600 permissions:
```python
# From security.py:174 (CORRECT approach)
with open(self.DEVICES_FILE, 'w') as f:
    json.dump(data, f, indent=2)
os.chmod(self.DEVICES_FILE, 0o600)  # ✅ Explicit permission setting
```

The AppConfig class omits this crucial security step.

2. **Default umask Risk**: When creating files without explicit permissions, the system umask (typically 022) is applied, resulting in:
- File: 666 & ~022 = 644 (rw-r--r--) - world-readable!
- Directory: 777 & ~022 = 755 (rwxr-xr-x) - world-executable!

3. **Sensitive Data Exposure**: settings.json contains:
```json
{
  "port": 54321,
  "stun_server": "stun:stun.l.google.com:19302",
  "turn_server": "",
  "security_require_auth": true,
  "security_require_pin": true,
  "security_auto_trust": false,
  "security_token_expiry": 300,
  "devices": [...],  // Device trust information
  ...
}
```

4. **Inconsistent Security**: The codebase has inconsistent security practices:
- SecurityManager: Sets 0o600 ✅
- AppConfig: No permission setting ❌

**Attack Scenario on Multi-User Systems:**
1. User A runs StreamLinux and configures streaming
2. settings.json created with 644 permissions
3. User B (with shell access) reads: `cat ~/.config/streamlinux/settings.json`
4. User B learns User A's security configuration, network settings, device trust status
5. This information can be used for targeted social engineering or combined with other exploits

## Remediation

1. **Set Restrictive File Permissions**:
   - Add `os.chmod(self.CONFIG_FILE, 0o600)` immediately after creating config file
   - This ensures only the file owner can read/write the configuration
   - Matches the secure approach already used in SecurityManager

2. **Secure Directory Permissions**:
   - Set config directory to 0o700 (user-only access)
   - Prevents other users from listing or accessing directory contents

3. **Implement Consistent Security**:
   - Apply same permission model across all sensitive files
   - Document security requirements in code comments

**Fixed Code Example**:
```python
def _save(self):
    """Save configuration to file"""
    try:
        # Create directory with secure permissions
        self.CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        os.chmod(self.CONFIG_DIR, 0o700)
        
        # Write config file
        with open(self.CONFIG_FILE, 'w') as f:
            json.dump(self._config, f, indent=2)
        
        # Set secure file permissions (user-only read/write)
        os.chmod(self.CONFIG_FILE, 0o600)
        
        print(f"Saved config to {self.CONFIG_FILE}")
    except Exception as e:
        print(f"Error saving config: {e}")
```

4. **Validate Existing Configurations**:
   - On application startup, check permissions of existing config files
   - Warn users if permissions are too permissive
   - Offer to fix permissions automatically

5. **Consider Additional Protections**:
   - Encrypt sensitive values (tokens, credentials) before storage
   - Use system keyring (e.g., libsecret) for highly sensitive data
   - Implement file integrity checks to detect unauthorized modifications

