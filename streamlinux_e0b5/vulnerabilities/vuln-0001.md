# SSRF via STUN Server with Logic Error Bypassing Private IP Restrictions

**ID:** vuln-0001
**Severity:** HIGH
**Found:** 2026-01-31 07:10:15 UTC
**Target:** /workspace/streamlinux
**Endpoint:** /linux-gui/webrtc_streamer.py
**CVSS:** 7.7

## Description

A server-side request forgery vulnerability exists in the STUN server validation function due to a logic error in exception handling. The validate_stun_server() function in webrtc_streamer.py attempts to block private IP ranges (RFC 1918, loopback, link-local) to prevent SSRF attacks. However, when a private IP is detected, a ValueError is raised but immediately caught by an inner try/except block with a pass statement, causing the function to ultimately return the malicious private IP URL instead of rejecting it.

The vulnerability allows an attacker to configure a STUN server pointing to internal IP addresses such as 169.254.169.254 (AWS metadata endpoint), 10.0.0.1 (private network), or 127.0.0.1 (localhost), potentially accessing cloud metadata services or internal network resources.

## Impact

An attacker can:
- Access cloud metadata services (169.254.169.254) to retrieve instance credentials
- Scan internal networks through the STUN server configuration
- Access localhost-only services on the streaming host
- Potentially exfiltrate sensitive data from internal services

This bypasses the intended SSRF protection implemented in response to the original vulnerability disclosure, rendering the fix ineffective.

## Technical Analysis

The vulnerability is located in the validate_stun_server() function (webrtc_streamer.py, lines 114-126):

```python
# Extraer host y validar que no sea IP privada (SSRF protection)
try:
    host_part = stun_server.split('://')[1].split(':')[0]
    try:
        ip = ipaddress.ip_address(host_part)
        if ip.is_private or ip.is_loopback or ip.is_link_local:
            raise ValueError(f"STUN server cannot use private/local IP: {host_part}")
    except ValueError:
        pass  # <-- BUG: Catches the ValueError raised by the SSRF check!
except Exception:
    pass

return stun_server  # Returns the private IP URL unmodified
```

The issue is that the inner try/except block catches ALL ValueError exceptions, including the one intentionally raised at line 120 when a private IP is detected. The comment "Es un hostname, no una IP - OK" suggests the intent was to handle hostnames that aren't valid IPs, but this implementation also catches and silently ignores the security exception.

The function then returns the original stun_server value (line 126) which contains the private IP, completely bypassing the SSRF protection.

## Proof of Concept

1. Launch the StreamLinux application
2. Navigate to network settings
3. Set the STUN server to an internal IP address:
   - stun://169.254.169.254:19302 (cloud metadata)
   - stun://10.0.0.1:19302 (private network)
   - stun://127.0.0.1:19302 (localhost)
4. The application accepts the configuration without error
5. The STUN server URL is passed to GStreamer's webrtcbin element
6. The application attempts connections to the internal IP

```
#!/usr/bin/env python3
"""Test SSRF bypass in validate_stun_server() function"""

def validate_stun_server(stun_server: str) -> str:
    """Original vulnerable function from webrtc_streamer.py"""
    import ipaddress
    
    if not stun_server:
        return "stun://stun.l.google.com:19302"
    
    # Rechazar caracteres de inyección GStreamer
    forbidden_chars = ['!', '|', '&', ';', '$', '`', '(', ')', '{', '}', '<', '>', '\n', '\r']
    for char in forbidden_chars:
        if char in stun_server:
            raise ValueError(f"STUN server contains forbidden character: '{char}'")
    
    # Validar formato
    import re
    pattern = r'^(stun|stuns|turn|turns)://[a-zA-Z0-9][a-zA-Z0-9.-]*:[0-9]{1,5}$'
    if not re.match(pattern, stun_server):
        raise ValueError(f"Invalid STUN server format: {stun_server}")
    
    # BUG: This check is bypassed due to exception handling
    try:
        host_part = stun_server.split('://')[1].split(':')[0]
        try:
            ip = ipaddress.ip_address(host_part)
            if ip.is_private or ip.is_loopback or ip.is_link_local:
                raise ValueError(f"STUN server cannot use private/local IP: {host_part}")
        except ValueError:
            pass  # BUG: Catches ALL ValueErrors, including our security check!
    except Exception:
        pass
    
    return stun_server  # Returns private IP!


# Test cases
test_urls = [
    "stun://10.0.0.1:19302",           # Class A private
    "stun://192.168.1.1:19302",        # Class C private
    "stun://172.16.0.1:19302",         # Class B private
    "stun://127.0.0.1:19302",          # Loopback
    "stun://169.254.169.254:19302",    # AWS metadata
    "stun://localhost:19302",          # Localhost hostname
    "stun://0.0.0.0:19302",            # Wildcard
]

print("Testing SSRF bypass in validate_stun_server():")
print("=" * 60)

for url in test_urls:
    try:
        result = validate_stun_server(url)
        status = "ACCEPTED (BUG!)" if result == url else "MODIFIED"
        print(f"Input:  {url}")
        print(f"Output: {result}")
        print(f"Status: {status}")
        print("-" * 60)
    except Exception as e:
        print(f"Input:  {url}")
        print(f"Error:  {e}")
        print(f"Status: BLOCKED (correct behavior)")
        print("-" * 60)
```

## Code Analysis

**File:** /workspace/streamlinux/linux-gui/webrtc_streamer.py

**Changes:**
```diff
--- a/linux-gui/webrtc_streamer.py
+++ b/linux-gui/webrtc_streamer.py
@@ -112,17 +112,18 @@ def validate_stun_server(stun_server: str) -> str:
         raise ValueError(f"Invalid STUN server format: {stun_server}")
     
     # Extraer host y validar que no sea IP privada (SSRF protection)
-    try:
-        host_part = stun_server.split('://')[1].split(':')[0]
-        try:
-            ip = ipaddress.ip_address(host_part)
-            if ip.is_private or ip.is_loopback or ip.is_link_local:
-                raise ValueError(f"STUN server cannot use private/local IP: {host_part}")
-        except ValueError:
-            pass  # Es un hostname, no una IP - OK
-    except Exception:
-        pass
+    host_part = stun_server.split('://')[1].split(':')[0]
+    
+    # Check if it's an IP address
+    try:
+        ip = ipaddress.ip_address(host_part)
+        # It's an IP - verify it's not private/local
+        if ip.is_private or ip.is_loopback or ip.is_link_local:
+            raise ValueError(f"STUN server cannot use private/local IP: {host_part}")
+    except ValueError:
+        # Not an IP address - check for localhost hostname
+        if host_part.lower() in ('localhost', '127.0.0.1', '::1'):
+            raise ValueError(f"STUN server cannot use localhost: {host_part}")
     
     return stun_server
```

## Remediation

1. Fix the exception handling logic to ONLY catch ValueError from ipaddress.ip_address() when the hostname is not a valid IP, not when we intentionally raise it for security reasons:

```python
# Extraer host y validar que no sea IP privada (SSRF protection)
try:
    host_part = stun_server.split('://')[1].split(':')[0]
    try:
        ip = ipaddress.ip_address(host_part)
        if ip.is_private or ip.is_loopback or ip.is_link_local:
            raise ValueError(f"STUN server cannot use private/local IP: {host_part}")
    except ValueError as e:
        # Only pass if this is from ip_address() parsing, not from our check
        if "does not appear to be an IPv4 or IPv6 address" in str(e):
            pass  # Es un hostname válido, continuar
        else:
            raise  # Re-raise our security ValueError
except ValueError as e:
    # Propagate security errors
    raise ValueError(f"Invalid STUN server: {e}")
except Exception:
    pass  # Hostname o formato válido

return stun_server
```

2. Alternative simpler fix - separate the IP validation from the hostname handling:

```python
host_part = stun_server.split('://')[1].split(':')[0]

# Check if it's an IP address
try:
    ip = ipaddress.ip_address(host_part)
    # It's an IP - check if private
    if ip.is_private or ip.is_loopback or ip.is_link_local:
        raise ValueError(f"STUN server cannot use private/local IP: {host_part}")
except ValueError:
    # Not an IP address - must be a public hostname
    # Additional hostname validation could go here
    pass
```

3. Add unit tests covering all private IP ranges, loopback, and link-local addresses

