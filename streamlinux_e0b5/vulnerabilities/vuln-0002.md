# Control Channel Authentication Bypass - Unauthorized Stream Control Remains Unfixed

**ID:** vuln-0002
**Severity:** HIGH
**Found:** 2026-01-31 07:11:09 UTC
**Target:** /workspace/streamlinux
**Endpoint:** /linux-host/src/control/control_channel.cpp
**CVSS:** 8.1

## Description

The control channel authentication bypass vulnerability (vuln-0005) has not been adequately remediated. The original vulnerability allowed any peer connected via WebRTC to send control messages (pause, resume, set resolution, set bitrate) without authentication or authorization. While input validation was added to check message format and parameter ranges, the fundamental issue - lack of authentication for control messages - remains unaddressed.

The process_message() function in control_channel.cpp directly processes control commands without verifying the sender's identity or authorization level. An attacker who establishes a WebRTC connection (even without proper room authorization) can send control messages to manipulate the streaming session.

## Impact

An attacker can:
- Pause/resume the stream at will, causing denial of service
- Change streaming resolution to exhaust bandwidth or cause display issues
- Modify bitrate settings to degrade streaming quality
- Change monitor selection to display unintended content
- Disrupt legitimate streaming sessions

This represents a complete lack of authorization for sensitive operations, allowing any connected peer to control the streaming session.

## Technical Analysis

The vulnerability exists in control_channel.cpp within the process_message() function (lines 27-80). The current implementation:

```cpp
void ControlChannel::process_message(const ControlMessage& msg) {
    if (!m_handler) return;
    
    switch (msg.type) {
        case ControlMessageType::Pause:
            m_handler->on_pause();
            break;
        case ControlMessageType::Resume:
            m_handler->on_resume();
            break;
        case ControlMessageType::SetResolution:
        case ControlMessageType::SetBitrate:
        case ControlMessageType::SelectMonitor:
            // Process without any auth check
            auto params = parse_message(msg.payload);
            if (params) {
                m_handler->on_parameters_changed(stream_params);
            }
            break;
        // ... other cases
    }
}
```

While parse_message() (lines 136-193) adds input validation (checking JSON format, numeric ranges, message size), it does NOT:
1. Verify the sender's identity
2. Check if the sender is authorized to send control commands
3. Validate session tokens or cryptographic signatures
4. Ensure the control message comes from the legitimate streaming client

The comment at line 137 "// Security: Validate and parse JSON control messages (vuln-0005)" suggests developers believed input validation alone would remediate the authentication bypass, but this is insufficient. An attacker can still send well-formed, valid control messages without being authorized to do so.

## Proof of Concept

1. Establish a WebRTC connection to a streaming host
2. Send a control message via the data channel without any authentication:
   ```json
   {"type": "SetResolution", "width": 320, "height": 240}
   ```
3. The host immediately processes the message and changes resolution
4. Send additional control messages:
   ```json
   {"type": "Pause"}
   {"type": "SetBitrate", "bitrate": 100000}
   ```
5. All commands are executed without any authorization check

```
#!/usr/bin/env python3
"""
Demonstrate control channel authentication bypass.
In a real attack, this would be sent via WebRTC data channel.
"""

import json

def send_control_message(msg_type, **params):
    """Simulate sending a control message"""
    msg = {"type": msg_type}
    msg.update(params)
    return json.dumps(msg)

# These messages would be processed WITHOUT authentication:
attack_messages = [
    send_control_message("Pause"),
    send_control_message("Resume"),
    send_control_message("SetResolution", width=640, height=480),
    send_control_message("SetBitrate", bitrate=100000),
    send_control_message("SetQuality", quality="low"),
    send_control_message("SelectMonitor", id=1),
    send_control_message("RequestKeyframe"),
]

print("Control Channel Authentication Bypass Test")
print("=" * 60)
print("These control messages are processed WITHOUT authentication:")
print()

for msg in attack_messages:
    data = json.loads(msg)
    print(f"Type: {data['type']}")
    print(f"Payload: {msg}")
    print("Status: ACCEPTED (no auth check)")
    print("-" * 60)

print("VULNERABILITY: Any connected peer can control the stream")
```

## Code Analysis

**File:** /workspace/streamlinux/linux-host/src/control/control_channel.cpp

**Changes:**
```diff
--- a/linux-host/src/control/control_channel.cpp
+++ b/linux-host/src/control/control_channel.cpp
@@ -24,7 +24,14 @@ void ControlChannel::set_handler(IControlHandler* handler) noexcept {
     m_handler = handler;
 }
 
-void ControlChannel::process_message(const ControlMessage& msg) {
+void ControlChannel::process_message(const ControlMessage& msg, const PeerIdentity& identity) {
     if (!m_handler) return;
     
+    // Security: Verify peer is authorized to send control commands (vuln-0005)
+    if (!identity.is_authorized_control_sender()) {
+        send_error("Control commands require authorization");
+        return;
+    }
+    
     switch (msg.type) {
         case ControlMessageType::Pause:
             m_handler->on_pause();
```

## Remediation

1. Implement peer authentication in the control channel:
   - Associate control messages with authenticated peer identity
   - Only accept control messages from authorized peers (the legitimate client, not arbitrary connections)

2. Add authorization checks before processing control commands:
```cpp
void ControlChannel::process_message(const ControlMessage& msg, const PeerCredentials& creds) {
    // Verify peer is authorized to send control commands
    if (!creds.is_authorized_control_sender()) {
        send_error("Unauthorized control attempt");
        return;
    }
    
    // Process message...
}
```

3. Implement session token validation for control messages

4. Add rate limiting for control messages to prevent abuse

5. Log all control operations for security auditing

