# Wayland Capture Buffer Overflow and Dimension Validation Not Enforced

**ID:** vuln-0004
**Severity:** MEDIUM
**Found:** 2026-01-31 07:14:47 UTC
**Target:** /workspace/streamlinux
**Endpoint:** /linux-host/src/capture/wayland_capture.cpp
**CVSS:** 5.3

## Description

The Wayland capture buffer overflow (vuln-0002) and frame dimension validation (vuln-0010) fixes are incomplete. While security constants MAX_FRAME_SIZE (256MB) and MAX_FRAME_DIMENSION (16384) were added to the code, they are defined but never actually used to validate incoming frame data from PipeWire.

The process_pipewire_frame() function directly uses buffer sizes and frame dimensions from the PipeWire stream without any validation against the defined security limits. This leaves the application vulnerable to memory exhaustion attacks or buffer overflows if a malicious PipeWire source sends oversized frames.

## Impact

An attacker who can influence the PipeWire stream (through compromised portal sessions or malicious applications) can:
- Cause memory exhaustion by sending extremely large frames
- Trigger buffer overflows in downstream processing
- Cause application crashes through invalid frame dimensions
- Potentially achieve code execution through memory corruption

The constants exist but provide no actual runtime protection.

## Technical Analysis

The vulnerability is in the process_pipewire_frame() function (wayland_capture.cpp, lines 581-637):

```cpp
void WaylandCapture::process_pipewire_frame() {
    struct pw_buffer* b = pw_stream_dequeue_buffer(m_pw_stream);
    if (!b) return;
    
    struct spa_buffer* buf = b->buffer;
    if (!buf->datas[0].data) {
        pw_stream_queue_buffer(m_pw_stream, b);
        return;
    }
    
    // Create video frame - NO VALIDATION OF DIMENSIONS
    VideoFrame frame;
    frame.pts = get_monotonic_pts();
    frame.width = m_video_format.info.raw.size.width;   // NO MAX_FRAME_DIMENSION CHECK
    frame.height = m_video_format.info.raw.size.height; // NO MAX_FRAME_DIMENSION CHECK
    frame.stride = buf->datas[0].chunk->stride;
    
    // Copy data - NO VALIDATION OF BUFFER SIZE
    size_t data_size = buf->datas[0].chunk->size;  // NO MAX_FRAME_SIZE CHECK
    frame.data.resize(data_size);
    std::memcpy(frame.data.data(), buf->datas[0].data, data_size);  // Potential overflow
}
```

The security constants are defined at lines 21-23 but never referenced:
```cpp
// Security: Maximum allowed frame size (vuln-0002)
static constexpr size_t MAX_FRAME_SIZE = 256ULL * 1024ULL * 1024ULL;  // 256MB
static constexpr uint32_t MAX_FRAME_DIMENSION = 16384;  // 16K max
```

This is a "security theater" fix - the constants suggest protection exists, but actual runtime enforcement is missing.

## Proof of Concept

A malicious PipeWire source could send frames with:
- Very large dimensions (e.g., 65536x65536) causing memory allocation failures
- Large buffer sizes exceeding available memory
- Invalid stride values causing memory corruption during copy

The application would attempt to process these without the defined limits being enforced.

```
#!/usr/bin/env python3
"""
Demonstrate that Wayland buffer validation constants exist but are unused.
This is a design/code review finding rather than a runtime exploit.
"""

print("Wayland Capture Buffer Security Analysis")
print("=" * 60)

print("Security constants DEFINED but UNUSED:")
print("  MAX_FRAME_SIZE = 256MB (line 22)")
print("  MAX_FRAME_DIMENSION = 16384 (line 23)")
print()

print("In process_pipewire_frame() (lines 581-637):")
print("  - frame.width assigned WITHOUT checking MAX_FRAME_DIMENSION")
print("  - frame.height assigned WITHOUT checking MAX_FRAME_DIMENSION")  
print("  - data_size used WITHOUT checking MAX_FRAME_SIZE")
print("  - memcpy performed WITHOUT size validation")
print()

print("VULNERABILITY: Constants exist but NO RUNTIME ENFORCEMENT")
print("IMPACT: Oversized frames from PipeWire can cause memory issues")
print()

print("Required fix: Add validation before processing:")
print('''
    // Validate dimensions
    if (frame.width > MAX_FRAME_DIMENSION || frame.height > MAX_FRAME_DIMENSION) {
        pw_stream_queue_buffer(m_pw_stream, b);
        return;
    }
    
    // Validate buffer size
    if (data_size > MAX_FRAME_SIZE) {
        pw_stream_queue_buffer(m_pw_stream, b);
        return;
    }
''')
```

## Code Analysis

**File:** /workspace/streamlinux/linux-host/src/capture/wayland_capture.cpp

**Changes:**
```diff
--- a/linux-host/src/capture/wayland_capture.cpp
+++ b/linux-host/src/capture/wayland_capture.cpp
@@ -591,6 +591,13 @@ void WaylandCapture::process_pipewire_frame() {
     frame.height = m_video_format.info.raw.size.height;
     frame.stride = buf->datas[0].chunk->stride;
     
+    // Security: Validate frame dimensions (vuln-0010)
+    if (frame.width > MAX_FRAME_DIMENSION || frame.height > MAX_FRAME_DIMENSION ||
+        frame.width == 0 || frame.height == 0) {
+        pw_stream_queue_buffer(m_pw_stream, b);
+        return;
+    }
+    
     // Determine pixel format
     switch (m_video_format.info.raw.format) {
         case SPA_VIDEO_FORMAT_BGRA:
@@ -604,6 +611,12 @@ void WaylandCapture::process_pipewire_frame() {
     
     // Copy data
     size_t data_size = buf->datas[0].chunk->size;
+    
+    // Security: Validate buffer size (vuln-0002)
+    if (data_size > MAX_FRAME_SIZE || data_size == 0) {
+        pw_stream_queue_buffer(m_pw_stream, b);
+        return;
+    }
+    
     frame.data.resize(data_size);
     std::memcpy(frame.data.data(), buf->datas[0].data, data_size);
```

## Remediation

1. Add dimension validation in process_pipewire_frame() after line 595:

```cpp
// Security: Validate frame dimensions (vuln-0010)
if (frame.width > MAX_FRAME_DIMENSION || frame.height > MAX_FRAME_DIMENSION ||
    frame.width == 0 || frame.height == 0) {
    pw_stream_queue_buffer(m_pw_stream, b);
    return;
}
```

2. Add buffer size validation before line 614:

```cpp
// Security: Validate buffer size (vuln-0002)
if (data_size > MAX_FRAME_SIZE || data_size == 0) {
    pw_stream_queue_buffer(m_pw_stream, b);
    return;
}
```

3. Consider adding stride validation to ensure it matches expected value

4. Add unit tests with oversized frames to verify the validation works

